//===============================================================================
//  [COG Minigun ]
// Firing modes:
//	single shot (zoomed if have optional zoom)
//  burst
//  grenade 
//===============================================================================
/* 
Anim names: 
load      (brings weapon up)
shoot1 \
shoot2   \ random cycle through these
shoot3   /
shoot4 /
spindown  (play this after it stops shooting)
holster   (puts weapon down)
--------------------------------
ammo10    (play this when you have 10 ammo left)
ammo9     (play this when you have 9 ammo left)
ammo8     (play this when you have 8 ammo left)
ammo7     (play this when you have 7 ammo left)
ammo6     (play this when you have 6 ammo left)
ammo5     (play this when you have 5 ammo left)
ammo4     (play this when you have 4 ammo left)
ammo3     (play this when you have 3 ammo left)
ammo2     (play this when you have 2 ammo left)
ammo1     (play this when you have 2 ammo left)
--------------------------------
load10   
load9
load8
load7
load6
load5
load4
load3
load2
load1
-------------------------------
holster10
holster9
holster8
holster7
holster6
holster5
holster4
holster3
holster2
holster1
-------------------------------
spindown10
spindown9
spindown8
spindown7
spindown6
spindown5
spindown4
spindown3
spindown2
spindown1

===============================================================================

 Unreal skeletal exporter - Animation information for [COGGatGun.psa] 

 Frames: 0
 Bones: 12
 

 * Animation sequence load    0  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  0  total raw frames 31  group: [None]

 * Animation sequence shoot1    1  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  31  total raw frames 5  group: [None]

 * Animation sequence shoot2    2  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  36  total raw frames 5  group: [None]

 * Animation sequence shoot3    3  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  41  total raw frames 5  group: [None]

 * Animation sequence shoot4    4  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  46  total raw frames 5  group: [None]

 * Animation sequence spindown    5  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  51  total raw frames 45  group: [None]

 * Animation sequence holster    6  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  96  total raw frames 31  group: [None]

 * Animation sequence ammo10    7  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  127  total raw frames 5  group: [None]

 * Animation sequence ammo9    8  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  132  total raw frames 5  group: [None]

 * Animation sequence ammo8    9  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  137  total raw frames 5  group: [None]

 * Animation sequence ammo7   10  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  142  total raw frames 5  group: [None]

 * Animation sequence ammo6   11  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  147  total raw frames 5  group: [None]

 * Animation sequence ammo5   12  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  152  total raw frames 5  group: [None]

 * Animation sequence ammo4   13  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  157  total raw frames 5  group: [None]

 * Animation sequence ammo3   14  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  162  total raw frames 5  group: [None]

 * Animation sequence ammo2   15  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  167  total raw frames 5  group: [None]

 * Animation sequence ammo1   16  Tracktime: 5.000000 rate: 30.000000 
	  First raw frame  172  total raw frames 5  group: [None]
 * Animation sequence load10   17  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  177  total raw frames 31  group: [None]

 * Animation sequence load9   18  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  208  total raw frames 31  group: [None]

 * Animation sequence load8   19  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  239  total raw frames 31  group: [None]

 * Animation sequence load7   20  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  270  total raw frames 31  group: [None]

 * Animation sequence load6   21  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  301  total raw frames 31  group: [None]

 * Animation sequence load5   22  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  332  total raw frames 31  group: [None]

 * Animation sequence load4   23  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  363  total raw frames 31  group: [None]

 * Animation sequence load3   24  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  394  total raw frames 31  group: [None]

 * Animation sequence load2   25  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  425  total raw frames 31  group: [None]

 * Animation sequence load1   26  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  456  total raw frames 31  group: [None]

 * Animation sequence holster10   27  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  487  total raw frames 31  group: [None]

 * Animation sequence holster9   28  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  518  total raw frames 31  group: [None]

 * Animation sequence holster8   29  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  549  total raw frames 31  group: [None]

 * Animation sequence holster7   30  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  580  total raw frames 31  group: [None]

 * Animation sequence holster6   31  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  611  total raw frames 31  group: [None]

 * Animation sequence holster5   32  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  642  total raw frames 31  group: [None]

 * Animation sequence holster4   33  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  673  total raw frames 31  group: [None]

 * Animation sequence holster3   34  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  704  total raw frames 31  group: [None]

 * Animation sequence holster2   35  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  735  total raw frames 31  group: [None]

 * Animation sequence holster1   36  Tracktime: 31.000000 rate: 30.000000 
	  First raw frame  766  total raw frames 31  group: [None]

 * Animation sequence spindown10   37  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  797  total raw frames 45  group: [None]

 * Animation sequence spindown9   38  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  842  total raw frames 45  group: [None]

 * Animation sequence spindown8   39  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  887  total raw frames 45  group: [None]

 * Animation sequence spindown7   40  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  932  total raw frames 45  group: [None]

 * Animation sequence spindown6   41  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  977  total raw frames 45  group: [None]

 * Animation sequence spindown5   42  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  1022  total raw frames 45  group: [None]

 * Animation sequence spindown4   43  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  1067  total raw frames 45  group: [None]

 * Animation sequence spindown3   44  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  1112  total raw frames 45  group: [None]

 * Animation sequence spindown2   45  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  1157  total raw frames 45  group: [None]

 * Animation sequence spindown1   46  Tracktime: 45.000000 rate: 30.000000 
	  First raw frame  1202  total raw frames 45  group: [None]

*/

//===============================================================================

class WeapCogMinigun extends WarfareWeapon;

#exec MESH  MODELIMPORT MESH=COGGatGun MODELFILE=..\WarClassContent\Models\COGGatGun.PSK LODSTYLE=0
#exec MESH  ORIGIN MESH=COGGatGun X=75 Y=128 Z=50 YAW=64 PITCH=00 ROLL=00
#exec ANIM  IMPORT ANIM=CogGatGunAnims ANIMFILE=..\WarClassContent\Models\COGGatGun.PSA COMPRESS=1 MAXKEYS=999999 IMPORTSEQS=1
#exec MESHMAP SCALE MESHMAP=COGGatGun X=0.5 Y=0.5 Z=0.5
#exec MESH  DEFAULTANIM MESH=COGGatGun ANIM=CogGatGunAnims

#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load  GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load1 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load2 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load3 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load4 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load5 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load6 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load7 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load8 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load9 GROUP=Select
#exec ANIM SEQUENCE ANIM=CogGatGunAnims SEQ=load10 GROUP=Select
#exec ANIM DIGEST ANIM=CogGatGunAnims USERAWINFO VERBOSE

#exec OBJ LOAD FILE=..\WarClassContent\Textures\WarHeavyWeapons.utx PACKAGE=WarClassHeavy
#exec OBJ LOAD FILE=..\Sounds\WeaponSounds.uax PACKAGE=WeaponSounds
#exec OBJ LOAD FILE=..\Textures\MuzzleFlashes.utx PACKAGE=MuzzleFlashes

#EXEC MESHMAP SETTEXTURE MESHMAP=COGGatGun NUM=0 TEXTURE=SC_GatGunTex
#EXEC MESHMAP SETTEXTURE MESHMAP=COGGatGun NUM=1 TEXTURE=SC_GatGunLED
#EXEC MESHMAP SETTEXTURE MESHMAP=COGGatGun NUM=2 TEXTURE=SC_BulletEnd

// Original material [0] is [Skin0] SkinIndex: 0 Bitmap: SC_GatGunTex.bmp  Path: C:\Work\Warfare\Guns\GatGun 
// Original material [1] is [Skin1] SkinIndex: 1 Bitmap: SC_GatGunLED.bmp  Path: C:\Work\Warfare\Guns\GatGun 

var name FireAnims[4];
var name LowAmmoAnims[10];
var name LoadAnims[10];
var name HolsterAnims[10];
var name SpinDownAnims[10];

var texture MuzzleFlashVariations[5];
var int pos;

var bool bTargetting;						// Are we targetting missles
var PlayerReplicationInfo Targets[12];		// Who is targetted
var int NoTargets;							// # of people locked on to
var vector MissleOffset;					// Where the missles come from.
var sound TargetLock;						// Sound to make when a target locks
var float lastRenderTime;					// Hacky Hacky

var WarCogHeavyCanopyAttachment Canopy;
var vector CanopyOffset;			

var RocketAmmo MissleAmmo;
var class<RocketAmmo> MissleAmmoClass;
var rotator OldRot;

var ScriptedTexture	LEDTexture;
var int				LEDAmmoCount;

replication
{
	reliable if (role < ROLE_Authority)
		ServerFireLoad, ServerAddLock;

	reliable if (role == ROLE_Authority)
		ClientApproveLock, ClientDoneLaunch;
		
	reliable if (bNetOwner && (ROLE==ROLE_Authority) )
		MissleAmmo;		
}

simulated event RenderTexture(ScriptedTexture Tex)
{
	local	Color C;

	C.R = 255;
	C.G = 255;
	C.B = 255;
	C.A = 255;

	Tex.DrawTile(
		0,0,
		64,32,
		0,0,
		64,32,
		Texture'BackgroundLED',
		C
		);

	C.G = 255 * AmmoType.AmmoAmount / AmmoType.MaxAmmo;
	C.R = 255 - C.G;
	C.B = 0;
	C.A = 255;

	Tex.DrawText(
		20,6,
		AmmoType.AmmoAmount,
		Font'MediumFont',
		C
		);

	LEDAmmoCount = AmmoType.AmmoAmount;
}

simulated exec function Jet1(int x, int y, int z)
{
	local Vector V;
	local COGHeavyInfantry H;
	
	H = COGHeavyInfantry(Instigator);
	if (h==none)
	{
		log("#### Can't set, not a HG");
		return;
	}
	
	if (h.JetEffect==None)
	{
		log("#### No Effect");
		return;
	}
	
	V.X = X;
	V.Y = Y;
	v.Z = Z;
	
	log("#### Setting Jet1 to "$V);
	
	h.JetEffect.Emitters[0].StartLocationOffset=V;	
	h.JetEffect.Emitters[1].StartLocationOffset=V;	

}

simulated exec function Jet2(int x, int y, int z)
{
	local Vector V;
	local COGHeavyInfantry H;
	
	H = COGHeavyInfantry(Instigator);
	if (h==none)
	{
		log("#### Can't set, not a HG");
		return;
	}
	
	if (h.JetEffect==None)
	{
		log("#### No Effect");
		return;
	}
	
	V.X = X;
	V.Y = Y;
	v.Z = Z;
	
	log("#### Setting Jet2 to "$V);
	
	h.JetEffect.Emitters[2].StartLocationOffset=V;	
	h.JetEffect.Emitters[3].StartLocationOffset=V;	

}

simulated exec function JetShow()
{
	local COGHeavyInfantry H;
	
	H = COGHeavyInfantry(Instigator);
	if (h==none)
	{
		log("#### Can't set, not a HG");
		return;
	}
	
	if (h.JetEffect==None)
	{
		log("#### No Effect");
		return;
	}
	log("##### Jet1: "$h.JetEffect.Emitters[0].StartLocationOffset);
	log("##### Jet1: "$h.JetEffect.Emitters[2].StartLocationOffset);
}

simulated exec function GScale(float x)
{
	SetDrawScale(x);
}

simulated exec function CScale(float x)
{
	Canopy.SetDrawScale(x);
}

simulated exec function COffset()
{
	log("### Canopy Offset: "$CanopyOffset);
}

simulated exec function CSetX(float x)
{
	CanopyOffset.X = x;
}
simulated exec function CSetY(float x)
{
	CanopyOffset.Y = x;
}
simulated exec function CSetZ(float x)
{
	CanopyOffset.Z = x;
}

simulated Event PostNetBeginPlay()
{
	// Spawn the Canopy on the client

	Super.PostNetBeginPlay();
	Canopy = spawn(class'WarCogHeavyCanopyAttachment');
	
	// Spawn the LED texture on the client.

	LEDTexture = ScriptedTexture(Level.ObjectPool.AllocateObject(class'ScriptedTexture'));
	LEDTexture.SetSize(64,32);
	LEDTexture.Client = Self;

	Skins[1] = LEDTexture;
}
	
simulated Event Destroyed()
{
	if (Canopy!=None)
		Canopy.Destroy();
		
	Super.Destroyed();
}	

simulated function PlayFiring()
{
	TraceAccuracy = Default.TraceAccuracy;
	PlayFiringAtRate(0.7 + 0.7 * FireAdjust);
}

simulated exec function Adjust(int which, int x, int y, int z)
{
	local WarCOGHeavy H;
	local vector v;

	v.x = x;
	v.y = y;
	v.z = z;
	
	log("#### Setting: "$v);
	
	H = WarCOGHeavy(Instigator);
	if (which==0)
	{
		H.JetEffect.Emitters[0].StartLocationOffset = v;
		H.JetEffect.Emitters[1].StartLocationOffset = v;
	}
	else
	{
		H.JetEffect.Emitters[2].StartLocationOffset = v;
		H.JetEffect.Emitters[3].StartLocationOffset = v;
	}
}

simulated exec function showjets()
{
	local WarCOGHeavy H;

	H = WarCOGHeavy(Instigator);
	log("#### Left Jet  : "$H.JetEffect.Emitters[0].StartLocationOffset);
	log("#### Right Jet : "$H.JetEffect.Emitters[2].StartLocationOffset);
}

simulated function Fire(float value)
{
	local name  AnimSequence;
	local float AnimFrame;
	local float AnimRate;

	Instigator.GetAnimParams( 0, AnimSequence, AnimFrame, AnimRate );
	if (AnimSequence=='deploy' || AnimSequence=='undeploy')
		return;
		
	Super.Fire(value);
}

simulated function AltFire( float Value )
{
	local name  AnimSequence;
	local float AnimFrame;
	local float AnimRate;

	Instigator.GetAnimParams( 0, AnimSequence, AnimFrame, AnimRate );
	if ( (AnimSequence=='deploy') || (AnimSequence=='undeploy') )
		return;

	if (!Instigator.bIsCrouched )	// Ignore AltFire when not Deployed
		return;
		
	Super.AltFire(Value);
		
	if (ROLE<Role_Authority)
	{
		GotoState('ClientTargetting');
	}
	
	ServerAltFire();				
}

function ServerAltFire()
{
	GotoState('Targetting');
}


simulated function PlayFiringAtRate(float rate)
{
	IncrementFlashCount();
	PlayOwnedSound(FireSound, SLOT_None, 3.0);
	if ( AmmoType.AmmoAmount > 10 )
		PlayAnim(FireAnims[rand(4)],rate,0.0);
	else 
		PlayAnim(LowAmmoAnims[AmmoType.AmmoAmount-1],rate,0.0);
}

simulated function TweenDown()
{
	local name Anim;
	local float frame,rate;

	if ( IsAnimating() && AnimIsInGroup(0,'Select') )
	{
		GetAnimParams(0,Anim,frame,rate);
		TweenAnim( Anim, frame * 0.4 );
	}
	else if ( AmmoType.AmmoAmount > 10 )
		PlayAnim('Holster', 1.0, 0.05);
	else 
		PlayAnim(HolsterAnims[AmmoType.AmmoAmount-1], 1.0, 0.05);
}

simulated function PlaySelect()
{
	bForceFire = false;
	bForceAltFire = false;
	if ( !IsAnimating() || !AnimIsInGroup(0,'Select') )
	{
		if ( AmmoType.AmmoAmount > 10 )
			PlayAnim('Load', 1.0, 0.0);
		else 
			PlayAnim(LoadAnims[AmmoType.AmmoAmount-1], 1.0, 0.0);
	}		
	Owner.PlaySound(SelectSound, SLOT_Misc, 1.0);	
}

function SetupMuzzleFlash()
{
	bMuzzleFlash = true;
	bSetFlashTime = false;
	FlashOffsetY = Default.FlashOffsetY * (1.08 - 0.16 * FRand());
	FlashOffsetX = Default.FlashOffsetX * (1 + 0.15 * FRand());
}

simulated function DrawHud(canvas Canvas, WarfareHud Hud, FontInfo Fonts, float Scale)
{
	local float tScale;
	local int Team;
	
	if ( Instigator == None )
		return;

	Canvas.SetPos(0,0);
	Canvas.Font = PlayerController(Instigator.Controller).MyHud.SmallFont;
	
	tScale = Scale;
	
	if (Scale<1)
		Scale=1;
		
	// Draw the Clip Ammo Display

	Canvas.Style = ERenderStyle.STY_Normal;
	Canvas.SetDrawColor(255,255,255);
	Team = Instigator.PlayerReplicationInfo.Team.TeamIndex; 
	Canvas.SetPos(0,0);
	Canvas.DrawTile(Hud.LeftHud[Team],191*Scale,98*Scale,0,0,191,98);

	Canvas.SetDrawColor(255,255,0);

	Canvas.Font = Fonts.GetHugeFont(Canvas.ClipX);
	Canvas.SetPos(73*Scale,10*Scale);
	Canvas.DrawText(AmmoType.AmmoAmount, false);
	
	Canvas.SetDrawColor(255,255,255);
	
	Canvas.SetPos(15*Scale, 54*Scale);
	Canvas.Font = Fonts.GetSmallestFont(Canvas.ClipX);
	Canvas.DrawText(""$MissleAmmo.AmmoAmount$" Missles", false);
	
	Scale=tScale;
	
}


//=============================================================================
// Weapon rendering
// Draw first person view of inventory
simulated event RenderOverlays( canvas Canvas )
{
	local rotator NewRot;
	local bool bPlayerOwner;
	local int Hand;
	local WarfarePlayer PlayerOwner;
	local float ScaledFlash, dx, Delta;
	local vector AimPoint,AimFrom, X,Y,Z;
	local int i;
	local WarCOGHeavy HG;
	
	if ( Instigator == None )
		return;

	PlayerOwner = WarfarePlayer(Instigator.Controller);
	if (PlayerOwner == None)
		return;

	bPlayerOwner = true;
	Hand = PlayerOwner.Handedness;
	if (  Hand == 2 )
		return;
			
	if ( (PlayerOwner.AimControl==None) || (!PlayerOwner.AimControl.bActive) ) 
		DrawCrosshair(Canvas);
	
	if ( (!PlayerOwner.Pawn.bIsCrouched) && bMuzzleFlash && bDrawMuzzleFlash && (MFTexture != None) )
	{
		if ( !bSetFlashTime )
		{
			bSetFlashTime = true;
			FlashTime = Level.TimeSeconds + FlashLength;
		}
		else if ( FlashTime < Level.TimeSeconds )
			bMuzzleFlash = false;
		if ( bMuzzleFlash )
		{
			ScaledFlash = 0.5 * MuzzleFlashSize * MuzzleScale * Canvas.ClipX/640.0;
			Canvas.SetPos(0.5*Canvas.ClipX - ScaledFlash + Canvas.ClipX * Hand * FlashOffsetX, 0.5*Canvas.ClipY - ScaledFlash + Canvas.ClipY * FlashOffsetY);
			DrawMuzzleFlash(Canvas);
		}
	}
	else
		bSetFlashTime = false;

	HG = WarCogHeavy(Instigator);
	AimPoint = Instigator.Location + Instigator.CalcDrawOffset(self);

	if (LastRenderTime==0)
		LastRenderTime = Level.TimeSeconds;
	
	// Handle the animation of the weapon sliding
	if (HG!=None)
	{
		if (HG.DesiredWeapXMod != HG.WeapXMod)
		{
				Delta = Level.Timeseconds - LastRenderTime;
				dx = 8 * Delta;

				if (HG.DesiredWeapXMod.X < HG.WeapXMod.X)
				{
					HG.WeapXMod.X -= dx;
					if (HG.WeapXMod.X < HG.DesiredWeapXMod.X)
						HG.WeapXMod.X = HG.DesiredWeapXMod.X;
				}
				else
				{
					HG.WeapXMod.X += dx;
					if (HG.WeapXMod.X > HG.DesiredWeapXMod.X)
						HG.WeapXMod.X = HG.DesiredWeapXMod.X;
				}			
					
		}
		AimPoint += HG.WeapXMod;
		
	}		

	LastRenderTime = Level.TimeSeconds;		
	SetLocation( Instigator.Location + Instigator.CalcDrawOffset(self)  );

	NewRot = Instigator.GetViewRotation();
	if ( Hand == 0 )
		newRot.Roll = 2 * Default.Rotation.Roll;
	else
		newRot.Roll = Default.Rotation.Roll * Hand;

	setRotation(newRot);
	Canvas.DrawActor(self, false, false, DisplayFOV);

	if (!Instigator.bIsCrouched )
	{
		GetAxes(Instigator.GetViewRotation(),X,Y,Z);	

		AimFrom = Instigator.Location + WarCOGHeavy(Instigator).CalcCanopyOffset(self) + (X * CanopyOffset.X) + (Y*CanopyOffset.Y) + (Z*CanopyOffset.Z);
		Canopy.SetLocation( AimFrom );
		NewRot = Instigator.GetViewRotation();
//		OldRot = NewRot;
//	}
//	else
//		NewRot = OldRot;

		Canopy.setRotation(NewRot);
	}
	Canvas.DrawActor(Canopy, false, true, DisplayFOV);

	if (MissleAmmo==None)
		return;
	
	Canvas.Font = PlayerController(Instigator.Controller).MyHud.SmallFont;
	for (i=0;i<12;i++)
	{
		Canvas.SetPos(5,Canvas.ClipY-16-(16*i));
		if (MissleAmmo.Slots[i].Status==1)
		{
			Canvas.SetDrawColor(255,0,0);
			Canvas.DrawText("Missle "$I$": "$MissleAmmo.Slots[i].Target.PlayerReplicationInfo.PlayerName);
		}
		else if (MissleAmmo.Slots[i].Status==0)
		{
			Canvas.SetDrawColor(0,255,0);
			Canvas.DrawText("Missle "$I$": ready");
		}
		else if (MissleAmmo.Slots[i].Status==2)
		{
			Canvas.SetDrawColor(128,128,255);
			Canvas.DrawText("Missle "$I$": reloading");
		}
		else
		{
			Canvas.SetDrawColor(128,128,128);			
			Canvas.DrawText("Missle "$I$": <offline>");
		}
	}	

	if(LEDAmmoCount != AmmoType.AmmoAmount)
		LEDTexture.Revision++;
}
simulated function DrawMuzzleFlash(Canvas Canvas)
{
	local float Scale, ULength, VLength, UStart, VStart;

	Scale = MuzzleScale * Canvas.ClipX/640.0;
	Canvas.Style = ERenderStyle.STY_Alpha;
	ULength = MFTexture.USize;
	if ( FRand() < 0.5 )
	{
		UStart = ULength;
		ULength = -1 * ULength;
	}
	VLength = MFTexture.VSize;
	if ( FRand() < 0.5 )
	{
		VStart = VLength;
		VLength = -1 * VLength;
	}

	Canvas.DrawTile(MFTexture, Scale * MFTexture.USize, Scale * MFTexture.VSize, UStart, VStart, ULength, VLength);
	Canvas.Style = ERenderStyle.STY_Normal;
}

simulated function bool TrackPlayer(canvas Canvas, float X, float Y, pawn P)
{

	local int i;
	local WarfarePawn WP;
	local WarfarePlayer PO;
	
	WP = WarfarePawn(P);
	if (WP==None)
		return false;

	PO = WarfarePlayer(Instigator.Controller);
	if ((PO==None) || (PO.AimControl == None) || (!PO.AimControl.bActive) )
	{
		WP.bSeeking = false;
		WP.bLocked = false;	
		return false;
	}
	
	if ( !Instigator.bIsCrouched || WP.Health<0 || WP.IsInState('Dying') || WP.bHidden || WP.bDeleteMe )	
	{
		WP.bSeeking = false;
		WP.bLocked = false;	
		return false;
	}
	
	// Cull out your teammates
	
	if (P.PlayerReplicationInfo.Team == Instigator.PlayerReplicationInfo.Team)
	{
		WP.bSeeking = false;
		WP.bLocked = false;
		return false;
	}

	// Set the roaming lock symbol		
		
	if ( (!WP.bLocked) && (!WP.bSeeking) )	// Start seeking the player for a lock
	{
	
		log("#### Resetting "$WP);
	
		WP.bSeeking = true;
		if (x < Canvas.ClipX/2)
		{
			WP.LockXMod[0] = Canvas.ClipX;
			WP.LockXMod[3] = Canvas.ClipX;
			WP.LockXMod[1] = -1;
		}
		else
		{
			WP.LockXMod[0] = -128;
			WP.LockXMod[1] = +1;
			WP.LockXMod[3] = -128;
		}
		
		WP.LastSeekTime = Level.TimeSeconds;
	}
			
	
	if (!WP.bLocked)	// Seek for the player
	{
	
		WP.LockXMod[0] += (Canvas.ClipX*2) * (Level.TimeSeconds - WP.LastSeekTime) * WP.LockXMod[1]; 
	
		if (WP.LockXMod[1]>0)
		{
			if (WP.LockXMod[0] > X)
				WP.bLocked = true;
				
		}
		else
		{
			if (WP.LockXMod[0]<X)
				WP.bLocked = true;
		}
	
	}		

	WP.LastSeekTime = Level.TimeSeconds;
	
	Canvas.SetDrawColor(255,255,0);
	for (i=0;i<NoTargets;i++)
	{
		if (WP.PlayerReplicationInfo == Targets[i])
		{
			Canvas.SetDrawColor(255,0,0);
			WP.bLocked = true;
		}
	}
	
	if (WP.bLocked)
		DrawPawnInfo(Canvas,X,Y,P,PO);
	else
		DrawPawnInfo(Canvas,WP.LockXMod[0],Y,P,PO);

	return true;
}


simulated function DrawPawnInfo(Canvas canvas, float screenX, float screenY, pawn P, WarfarePlayer C)
{
	// draw range to target info

	local float DistanceScale;

	Canvas.Style = 1;
	DistanceScale = (640 / ( Vsize(P.Location - Instigator.Location) * (C.FOVAngle/85) ) );
	DistanceScale = fClamp(DistanceScale*0.5,0.025,0.75);	
	Canvas.SetPos(0,200);
	Canvas.DrawText("DS:"$DistanceScale$" X/Y: "$ScreenX$","$ScreenY);
	
	Canvas.SetPos(ScreenX-(128*DistanceScale), ScreenY-(128*DistanceScale));
	Canvas.DrawTile(Shader 'WarClassHeavy.CogGatGun.LockedHair', 256*DistanceScale, 256*DistanceScale,0,0,256,256);
	
}

function TraceFire( float Accuracy, float YOffset, float ZOffset )
{
	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
	local actor Other;
	local WarfarePlayer PlayerOwner;

	PlayerOwner = WarfarePlayer(Instigator.Controller);
	if ( (PlayerOwner == None) || (!PlayerOwner.Pawn.bIsCrouched ) )
	{
		Super.TraceFire(Accuracy, YOffset, ZOffset);
		return;
	}

	Owner.MakeNoise(1.0);
	StartTrace = GetFireStart(X,Y,Z);
	EndTrace = PlayerOwner.AlternateAim;
	Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);
	AmmoType.ProcessTraceHit(self, Other, HitLocation, HitNormal, X,Y,Z);
}

////////////////////////////////////////////////////////
state FinishFire
{
	function Fire(float F) {}
	function AltFire(float F) {}

	function ServerFire()
	{
		bForceFire = true;
	}

	function AnimEnd(int Channel)
	{
		Finish();
		log("FinishFire now in state "$GetStateName());
	}

	function ServerAltFire()
	{
		bForceAltFire = true;
	}

	function BeginState()
	{
		if ( AmmoType.AmmoAmount > 10 )
			PlayAnim('SpinDown');
		else 
			PlayAnim(SpinDownAnims[AmmoType.AmmoAmount-1]);
	}
}

///////////////////////////////////////////////////////
state NormalFire
{

	simulated event RenderOverlays( canvas Canvas )
	{
		SetupMuzzleFlash();
		Global.RenderOverlays(Canvas);
	}

	function AnimEnd(int Channel)
	{
		local bool bForce, bForceAlt;

		bForce = bForceFire;
		bForceAlt = bForceAltFire;
		bForceFire = false;
		bForceAltFire = false;

		if ( Instigator.Weapon != self ) 
			GotoState('');
		else if ( AIController(Instigator.Controller) != None )
		{
			if ( AIController(Instigator.Controller).WeaponFireAgain(AmmoType.RefireRate,true) )
				Global.ServerFire();
			else 
				GotoState('FinishFire');
		}
		else if ( (StopFiringTime > Level.TimeSeconds) || bForce || Instigator.PressingFire() ) // || Instigator.PressingAltFire() )
			Global.ServerFire();
		else 
			GotoState('FinishFire');
	}

	function BeginState()
	{
		Super.BeginState();
		Instigator.bSteadyFiring = true;
	}

	function ServerAltFire()
	{
		PlayAnim('SpinDown');
		GotoState('Targetting');
	}
	
	function EndState()
	{  
		Super.EndState();
		if ( Instigator != None )
			Instigator.StopPlayFiring();
		bMuzzleFlash = false;
	}
}

state ClientFiring
{
	function Fire(float F) {}

	simulated event RenderOverlays( canvas Canvas )
	{
		SetupMuzzleFlash();
		Global.RenderOverlays(Canvas);
	}

	simulated function AnimEnd(int Channel)
	{
		if ( (Instigator == None) || (Instigator.Controller == None) )
		{
			GotoState('');
			return;
		}
		if ( Instigator.PressingFire() )
			Global.Fire(0);
		else if ( Instigator.PressingAltFire() )
			Global.Fire(0);
		else
			GotoState('ClientFinishing');
	}

	simulated function EndState()
	{
		Super.EndState();
		PlayAnim('spindown');
		bMuzzleFlash = false;
	}
}

////////////////////////////////////////////////////////

state ClientFinishing
{
	simulated function AnimEnd(int Channel)
	{
		ClientFinish();
	}

	simulated function EndState()
	{
		AmbientSound = None;
	}

	simulated function BeginState()
	{
		PlayAnim('spindown');
		Instigator.StopPlayFiring();
	}
}

/////////////////////////////////////////////

function ServerAddLock(PlayerReplicationInfo PRI, vector Location)
{
	local Controller C;
	local Pawn Target;
	
	C = Controller(PRI.Owner);
	Target = C.Pawn;
	if (Target!=None)
		MissleAmmo.LockOn(Target);

	return;		
		
	if (NoTargets==12)
		return;

	Targets[NoTargets] = PRI;
	NoTargets++;
	
	ClientApproveLock(PRI);	
}
			       	
simulated function ClientApproveLock(PlayerReplicationInfo PRI)
{
	Targets[NoTargets] = PRI;
	NoTargets++;
}	

state Targetting
{
	function EndState()
	{
		bTargetting = false;
	}
	
	function BeginState()
	{
		bTargetting = true;
	}
	
	simulated function Fire(float F) 
	{
		local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
		local actor Other;
		local WarfarePlayer PlayerOwner;
	
		PlayerOwner = WarfarePlayer(Instigator.Controller);
		StartTrace = GetFireStart(X,Y,Z);
		EndTrace = PlayerOwner.AimControl.AimTarget;
		Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);

		if ( PAwn(Other)!=None )
		{
			ServerAddLock(Pawn(Other).PlayerReplicationInfo, Other.Location);			
		}		
	}

	simulated function Tick(float delta)
	{
		if (!Instigator.isLocallyControlled())
			return;
			
		if ( !Instigator.PressingAltFire() )
		{
			ServerFireLoad();
		}
	}
	
}

state ClientTargetting
{
	simulated function BeginState()
	{
		bTargetting = true;
	}
	
	simulated function EndState()
	{
		bTargetting = false;
	}

	simulated function Fire(float F) 
	{
		local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
		local actor Other;
		local WarfarePlayer PlayerOwner;
	
		PlayerOwner = WarfarePlayer(Instigator.Controller);
		StartTrace = GetFireStart(X,Y,Z);
		EndTrace = PlayerOwner.AimControl.AimTarget;
		Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);

		if ( PAwn(Other)!=None )
		{
			ServerAddLock(Pawn(Other).PlayerReplicationInfo, Other.Location);			
		}		

	}

	simulated function Tick(float delta)
	{
		if ( !Instigator.PressingAltFire() )
		{
			ServerFireLoad();
			GotoState('Idle');
		}
	}
} 

function ServerFireLoad()
{
	local name  AnimSequence;
	local float AnimFrame;
	local float AnimRate;

	Instigator.GetAnimParams( 0, AnimSequence, AnimFrame, AnimRate );
	if (AnimSequence=='deploy' || AnimSequence=='undeploy')
		return;
	else
		GotoState('Launch');
}

//////////////////////////////////

function vector GetSpawnLocation(int m)
{
	local coords C;
	local vector v,x,y,z;

	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	
	if ( (M & 0x01) == 0x01)
	{
//		C = Instigator.GetBoneCoords('right_misslepack');
		C = Instigator.GetBoneCoords(WarCogHeavy(Instigator).GetMissleBoneFor('right'));
		V = C.Origin + X + (Y*+20) + Z;
	}
	else
	{
//		C = Instigator.GetBoneCoords('left_misslepack');
		C = Instigator.GetBoneCoords(WarCogHeavy(Instigator).GetMissleBoneFor('Left'));
		V = C.Origin + X + (Y*+5) + Z;
	}
		
	return V;		
		
}

function Rotator GetSpawnRotation()
{
	local WarfarePlayer PC;
	local rotator r;

	// Figure out where it's going

	PC = WarfarePlayer(Instigator.Controller);

	if (PC==None)
		r = Instigator.GetViewRotation(); 
	else
		r = Rotator(PC.AlternateAim-Instigator.Location);		

	return r; 
}

state Launch
{

	simulated function Fire(float x);
	simulated function Altfire(float x);

	function ServerFire();
	function ServerAltFire();

	function FireSingle()
	{
		local ProjCOGHeavyRocket DR;
		local WarfarePlayer PC;
		local vector sp;
		local Rotator LaunchRot;

		// Figure out where it's going

		PC = WarfarePlayer(Instigator.Controller);

		if (WarCogHeavy(Instigator) != None)
		{
			WarCogHeavy(Instigator).MissleFire++;
			sp = GetSpawnLocation(WarCogHeavy(Instigator).MissleFire) + MissleOffset;			
		}
		else
		  sp = Instigator.Location + MissleOffset;  				
		
		if (PC==None)
			LaunchRot = Instigator.GetViewRotation(); 
		else
			LaunchRot = Rotator(PC.AlternateAim-Instigator.Location);
		
		DR=Spawn(class 'ProjCOGHeavyRocket', instigator,,SP, LaunchRot);

		if (DR!=None)
		{
			DR.MisslePosition = WarCogHeavy(Instigator).MissleFire;
		}

		GotoState('Idle');
		ClientDoneLaunch();
	}

	function Timer()
	{
		local int Slot;
		
		Slot = MissleAmmo.FindNextLock();
		MissleAmmo.SpawnRocket(Slot);
		
		if (MissleAmmo.NoLocks()==0)
		{
			GotoState('Idle');
			ClientDoneLaunch();
		}
		
		SetTimer(0.25,true);
	}	
	
begin:

	if (MissleAmmo.NoLocks()==0)
	{
		MissleAmmo.LaunchRocket();
		GotoState('Idle');
		ClientDoneLaunch();
	}
	else
		Timer();		// Short Circuit launch one

}

simulated function ClientdoneLaunch()
{
	GotoState('Idle');
	NoTargets=0;
}

state ClientLaunch	// Dummy state that does nothing for right now
{
	simulated function Fire(float x);
	simulated function Altfire(float x);
}

function GiveAmmo( Pawn Other )
{

	MissleAmmo = RocketAmmo(Other.FindInventoryType(MissleAmmoClass));
	if (MissleAmmo != None)
		MissleAmmo.AddAmmo(48);
	else
	{
		MissleAmmo = Spawn(MissleAmmoClass);
		Other.AddInventory(MissleAmmo);
		MissleAmmo.MyWeapon = self;
	}

	Super.GiveAmmo(Other);		
}	



defaultproperties
{
	FireAnims[0]=Shoot1
	FireAnims[1]=shoot2
	FireAnims[2]=shoot3
	FireAnims[3]=shoot4
	LowAmmoAnims[0]=ammo1
	LowAmmoAnims[1]=ammo2
	LowAmmoAnims[2]=ammo3
	LowAmmoAnims[3]=ammo4
	LowAmmoAnims[4]=ammo5
	LowAmmoAnims[5]=ammo6
	LowAmmoAnims[6]=ammo7
	LowAmmoAnims[7]=ammo8
	LowAmmoAnims[8]=ammo9
	LowAmmoAnims[9]=ammo10
	LoadAnims[0]=load1
	LoadAnims[1]=load2
	LoadAnims[2]=load3
	LoadAnims[3]=load4
	LoadAnims[4]=load5
	LoadAnims[5]=load6
	LoadAnims[6]=load7
	LoadAnims[7]=load8
	LoadAnims[8]=load9
	LoadAnims[9]=load10
	HolsterAnims[0]=holster1
	HolsterAnims[1]=holster2
	HolsterAnims[2]=holster3
	HolsterAnims[3]=holster4
	HolsterAnims[4]=holster5
	HolsterAnims[5]=holster6
	HolsterAnims[6]=holster7
	HolsterAnims[7]=holster8
	HolsterAnims[8]=holster9
	HolsterAnims[9]=holster10
	SpinDownAnims[0]=spindown1
	SpinDownAnims[1]=spindown2
	SpinDownAnims[2]=spindown3
	SpinDownAnims[3]=spindown4
	SpinDownAnims[4]=spindown5
	SpinDownAnims[5]=spindown6
	SpinDownAnims[6]=spindown7
	SpinDownAnims[7]=spindown8
	SpinDownAnims[8]=spindown9
	SpinDownAnims[9]=spindown10
	MuzzleFlashVariations[0]=Texture'COGGatGun.SC_GatMuz4'
	MuzzleFlashVariations[1]=Texture'COGGatGun.SC_GatMuz5'
	MuzzleFlashVariations[2]=Texture'COGGatGun.SC_GatMuz6'
	MuzzleFlashVariations[3]=Texture'COGGatGun.SC_GatMuz4'
	MuzzleFlashVariations[4]=Texture'COGGatGun.SC_GatMuz6'
	MissleOffset=(X=20,Y=0,Z=0)
	TargetLock=Sound'WeaponSounds.COGGatGun.HeavyLock'
	CanopyOffset=(X=4,Y=-4.2,Z=-2)
	MissleAmmoClass=Class'RocketAmmo'
	AmmoName=Class'WarClassLight.MinigunAmmo'
	PickupAmmoCount=500
	bRapidFire=true
	AutoSwitchPriority=7
	FireOffset=(X=20,Y=4,Z=-5)
	ShakeMag=350
	shaketime=0.2
	ShakeVert=(X=0,Y=0,Z=4)
	TraceAccuracy=0.8
	aimerror=700
	AIRating=0.99
	FireSound=Sound'WeaponSounds.COGGatGun.minigun_shoot'
	SelectSound=Sound'WarClassLight.Rifle.RiflePickup'
	DisplayFOV=50
	FlashOffsetY=0.15
	FlashOffsetX=0.04
	MuzzleFlashSize=256
	MFTexture=Texture'MuzzleFlashes.2D.C_Muzzle2DHeavy_T_SC'
	bDrawMuzzleFlash=true
	InventoryGroup=7
	PickupClass=Class'PickupCOGMinigun'
	PlayerViewOffset=(X=8,Y=4,Z=-3)
	BobDamping=0.975
	AttachmentClass=Class'AttachmentCOGMinigun'
	ItemName="Gattling Gun"
	Mesh=SkeletalMesh'COGGatGun'
	DrawScale=0.06
	Skins=/* Array type was not detected. */
}