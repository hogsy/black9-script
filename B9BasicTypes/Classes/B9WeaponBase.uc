//=============================================================================
// B9WeaponBase
//
// 
//	Base weapon object
// 
//=============================================================================



class B9WeaponBase extends Weapon
	native
	abstract;



//////////////////////////////////
// Resource imports
//
#exec OBJ LOAD FILE=..\animations\B9Weapons_models.ukx PACKAGE=B9Weapons_models
#exec OBJ LOAD FILE=..\Sounds\B9SoundFX.uax PACKAGE=B9SoundFX
#exec TEXTURE IMPORT NAME=CHair1  FILE=..\HUD\Textures\green1.PCX GROUP="Icons" MIPS=OFF

//////////////////////////////////
// Definitions
//

const SNIPERTEXTURE_SIZE=512;

//////////////////////////////////
// Variables
//

// To alter the order of weapons, just change the position
// of that weapon's ID in the list
//
enum eWeaponID
{
	wepID_MeleeHandToHand,

	wepID_MeleeKatana,
	wepID_MeleeDagger,
	wepID_MeleeBlackjack,
	wepID_MeleeTazer,
	wepID_MeleeBlitSword,
	wepID_MeleeBlitDagger,

	wepID_Pistol9mm,
	wepID_PistolMagnum,
	wepID_PistolSilenced,
	wepID_PistolTazer,
	wepID_PistolSuitcase,
	wepID_PistolSMG,
	wepID_PistolSawedShotgun,

	wepID_RifleShotgun,
	wepID_RifleSniper,
	wepID_RifleDBShotgun,
	wepID_RifleAssault,

	wepID_HeavyGrenadeLauncher,
	wepID_HeavyHeavyMgun,
	wepID_HeavyRailgun,
	wepID_HeavyFlamethrower,
	wepID_HeavyRocketLauncher,
	wepID_HeavyRadFlux,

	wepID_SpecialCrossbow,
	wepID_SpecialGrapplingHook,
	wepID_SpecialSwarmGun,
};


var float	fOptimalRange;			// range out to where ammo does full damage
var float	fAccuracyFalloff;		// fuzz in aim beyond optimal range
var int		fAmmoExpendedPerShot;	// Number of rounds used from the magazine per shot. This will usually be 1.
var float	fROF;					// Rate-Of-Fire; 1.0 means once per second.
var float	fNoiseLevel;			// The amount of noise generated by the weapon firing. This is for alerting AI actors in single-player.
var float	fFireSoundVolumeLevel;	// Volume of fire sound. More for multiplayer than single.
var float	fFireSoundRadius;		// Radius in which the fire sound can be heard. More for multiplayer than single.
var float   fKickback;				// Kickback on pawn firing weapon

var sound	fEmptySound;			// Sound made when empty gun is fired (click!)
var sound	fReloadSound;			// Sound made when reloading

// The following is for the AI to give it information about the weapon.
var float	fMinRange;				// The minimum range at which the weapon should be fired.

// The following are used by the B9_PlayerController to manipulate
var public	bool fHasScope;
var public	bool fZoomed;		
var public	float fScopeMagnify;		
var public	float fScopeMaxMagnify;
									
var protected material fSniperReticule;
var protected material fSniperBackdrop;

var sound	fHolsterSound;

var eWeaponID		fUniqueID;

var bool	fUsesAmmo;
var bool	fUsesClips;

var string	fForceFeedbackEffectName;

var bool	fShotgunWeapon;
var byte	fShotgunPellets;
var bool	fStreamyWeapon;
var bool	fMeleeWeapon;
var int		fMeleeDamage;
var bool	fProjectileWeapon;
var string	fIniLookupName;

var float	fIntrinsicInaccuracy;
var float	fAccumulatedInaccuracy;
var float	fMaxInaccuracy;
var float	fInaccuracyIncrement;
const		kTargetingSkillScaleFactor = 0.05;


native(2020) final function		InitIniStats();



//////////////////////////////////
// Network Replication
//
replication
{
	// Things the server should send to the client.
	reliable if( bNetOwner && bNetDirty && (Role==ROLE_Authority) )
		fROF, fUsesAmmo, fUsesClips, fHasScope, fZoomed,
		fUniqueID;

	// Server functions called by client
	reliable if( Role <ROLE_Authority )
		ClientStoppedPressingFire;
}


//////////////////////////////////
// Functions
//

simulated event PostBeginPlay()
{
	Super.PostBeginPlay();

	InitIniStats();

	Default.ReloadCount = ReloadCount;
}

simulated function bool NeedsToReload()
{
	if( !Instigator.IsHumanControlled() )
	{
		return false;
	}
	
	if( fMeleeWeapon || !fUsesAmmo )
	{
		return false;
	}
	return ( bForceReload || (Default.ReloadCount > 0) && (ReloadCount == 0) );
}

function bool HandlePickupQuery( Pickup Item )
{
	if( Item.Class == AmmoType.PickupClass && NeedsToReload() && !IsInState( 'Reloading' ) && Pawn( Owner ).Weapon == Self )
	{
		GotoState( 'Reloading' );
		ClientForceReload();
	}

	return Super.HandlePickupQuery( Item );
}


simulated function AdjustAccuracy( optional bool bResetAccuracy )
{
	local B9_AdvancedPawn	P;

	P = B9_AdvancedPawn( Owner );
	if( fStreamyWeapon || P == None || !Instigator.IsHumanControlled() )
	{
		TraceAccuracy = 0.0;
		return;
	}

	if( bResetAccuracy )
	{
		fAccumulatedInaccuracy	= 0.0;
		TraceAccuracy			=  fIntrinsicInaccuracy - ( P.GetTargetingSkill() * kTargetingSkillScaleFactor );
		if( TraceAccuracy < 0.0 )
		{
			TraceAccuracy = 0.0;
		}
		else if( TraceAccuracy > fMaxInaccuracy )
		{
			TraceAccuracy = fMaxInaccuracy;
		}
		return;
	}

	fAccumulatedInaccuracy	+= fInaccuracyIncrement;
	TraceAccuracy			=  ( fIntrinsicInaccuracy + fAccumulatedInaccuracy ) - ( P.GetTargetingSkill() * kTargetingSkillScaleFactor );
	if( TraceAccuracy < 0.0 )
	{
		TraceAccuracy = 0.0;
	}
	else if( TraceAccuracy > fMaxInaccuracy )
	{
		TraceAccuracy = fMaxInaccuracy;
	}	
}

//////////////////////////////////
// Supports action exclusivity 
//
simulated function SetActionExclusivity( bool exclusive )
{
	local B9_BasicPlayerPawn	P;

	P = B9_BasicPlayerPawn( Owner );
	
	if( P == None )
	{
		return;
	}

	P.ActExclusively( exclusive );
}

simulated function bool CanFire()
{
	local B9_BasicPlayerPawn	P;

	if( Pawn( Owner ).IsHumanControlled() )
	{
		P = B9_BasicPlayerPawn( Owner );
		if( P == None || P.IsPerformingExclusiveAction() )
		{
			return false;
		}
		return true;
	}
	
	return true;
}
//
//////////////


simulated function int GetAmmoUsedPerShot()
{
	return fAmmoExpendedPerShot;
}

simulated function int GetMagazineCapacity()
{
	return Default.ReloadCount;
}

simulated function int GetRoundsInCurrentClip()
{
	return ReloadCount;
}

simulated function float GetROF()
{
	if( fROF > 0 )
	{
		return 60.0 / fROF;
	}
	log( "Bad ROF on "$self );
	return 1000.0;
}

simulated function float GetNoiseLevel()
{
	return fNoiseLevel;
}

simulated function sound GetFireSound()
{
	return FireSound;
}

simulated function sound GetEmptySound()
{
	return fEmptySound;
}

simulated function sound GetReloadSound()
{
	return fReloadSound;
}

simulated function SetRoundsInCurrentClip( int rounds )
{
	ReloadCount = rounds;
}

simulated function AddRoundsToClip( int rounds )
{
	ReloadCount += rounds;
}

simulated function ExpendAmmoFromClip()
{
	if( Instigator.IsHumanControlled() )
	{
		if( fUsesAmmo )
		{
			ReloadCount -= fAmmoExpendedPerShot;
			if( ReloadCount < 0 )
			{
				ReloadCount = 0;
			}
		}
	}
}

simulated function bool UsesAmmo()
{
	return fUsesAmmo;
}

simulated function bool UsesClips()
{
	return fUsesClips;
}

simulated function int GetUniqueID()
{
	return fUniqueID;
}

//////////////////////////////////
// 
//
simulated event RenderOverlays( canvas Canvas )
{
	if( fHasScope && fZoomed )
	{
		DrawSniperReticule(Canvas);
	}
}

simulated function DrawWeapon(canvas Canvas)
{
	// Draw 1st Person weapons here
}

function DrawSniperReticule( canvas Canvas )
{
	local vector X, Y, Z;
	local vector hitLoc, hitNormal, traceEnd, traceStart;
	local PlayerController playerController;
	local actor		TraceHitActor;
	local Pawn		TraceHitPawn;
	local float		RangeInUnits, RangeInMeters;
	local font		origFont;
	local string	rangeStr;


	playerController = PlayerController(Instigator.Controller);

	if ( playerController == None )
	{
		return;
	}

	if ( !playerController.bBehindView && B9WeaponBase(Instigator.Weapon) != None && 
		B9WeaponBase(Instigator.Weapon).fHasScope )
	{
		// Draw the reticle
		//
		Canvas.Style = ERenderStyle.STY_Translucent;
		Canvas.DrawColor.R = 255;
		Canvas.DrawColor.G = 255;
		Canvas.DrawColor.B = 255;
		
		
		Canvas.SetPos( 0, 0 );
		Canvas.DrawTile( fSniperBackdrop, Canvas.ClipX, Canvas.ClipY, 
			0, 0, SNIPERTEXTURE_SIZE - 1, SNIPERTEXTURE_SIZE - 1 );
		
		
		Canvas.SetPos( ( Canvas.ClipX * 0.5 ) - ( SNIPERTEXTURE_SIZE * 0.5 ),
			( Canvas.ClipY * 0.5 ) - ( SNIPERTEXTURE_SIZE * 0.5 ) );
		
		Canvas.DrawTile( fSniperReticule, SNIPERTEXTURE_SIZE, SNIPERTEXTURE_SIZE, 
			0, 0, SNIPERTEXTURE_SIZE, SNIPERTEXTURE_SIZE );


		// Now do a trace and see if we hit anything. If we do,
		// display the range to target for some flavor
		//
		SniperTrace( TraceHitActor, RangeInUnits );
				
		if( TraceHitActor != None )
		{
			TraceHitPawn = Pawn( TraceHitActor );
			if( TraceHitPawn != None )
			{
				RangeInMeters = RangeInUnits / 78.74;
				rangeStr = "RANGE:  ";
				rangeStr = rangeStr $ RangeInMeters;
				rangeStr = rangeStr $ "  METERS";

				origFont		= Canvas.Font;
				Canvas.Font		= Canvas.SmallFont;
				Canvas.SetDrawColor( 40, 255, 40 );
				Canvas.SetPos( ( Canvas.ClipX - 200 ), ( Canvas.ClipY - 60 ) );
				Canvas.DrawText( rangeStr, false );

				Canvas.Font		= origFont;
			}
		}		
	}
}



//////////////////////////////////
// 
//
function ApplyKick()
{
	return;
	/*
	CalcKick();
	if (fKickback != 0.0f)
		B9_AdvancedPawn(Instigator).ClientKickView(fKickback);
	*/	
}

function CalcKick()
{
	// weapons can override
}

// A range-only version of Weapon.CanAttack() using Owner & Target (I guess)
function bool IsTargetInRange()
{
	local float MaxDist;
	local Pawn Pawn;

	Pawn = Pawn(Owner);

	if ( Pawn == None || Pawn.Controller != None || Pawn.Controller.Target == None )
		return false;

	// check that target is within range
	MaxDist = MaxRange;
	if ( AmmoType.bInstantHit )
		MaxDist = TraceDist;
	if ( VSize(Pawn.Location - Pawn.Controller.Target.Location) > MaxDist )
		return false;
	return true;
}

// Overridden to use fUniqueID instead of InventoryGroup.
// InventoryGroup is "supposed" to be 0-9 only which is
// no good for our purposes, and if they enforce that later
// we're in trouble if we've used it for values > 9.
//
simulated function float SwitchPriority() 
{
	local float temp;

	if ( !Instigator.IsHumanControlled() )
		return RateSelf();
	else
		return Default.AutoSwitchPriority;
}

simulated function Weapon WeaponChange( byte F, bool bSilent )
{	
	local Weapon newWeapon;
	 
	if ( fUniqueID == F )
	{
		return self;
	}
	else if ( Inventory == None )
		return None;
	else
		return Inventory.WeaponChange(F, bSilent);
}

simulated function Weapon RecommendWeapon( out float rating )
{
	local Weapon Recommended;
	local float oldRating, oldFiring;
	local int oldMode;

	if ( Instigator.IsHumanControlled() )
		rating = SwitchPriority();
	else
	{
		rating = RateSelf();
		if ( (self == Instigator.Weapon) && (Instigator.Controller.Enemy != None) 
			&& AmmoType.HasAmmo() )
			rating += 0.21; // tend to stick with same weapon
			rating += Instigator.Controller.WeaponPreference(self);
	}
	if ( inventory != None )
	{
		Recommended = inventory.RecommendWeapon(oldRating);
		if ( (Recommended != None) && (oldRating > rating) )
		{
			rating = oldRating;
			return Recommended;
		}
	}
	return self;
}

function GiveAmmo( Pawn Other )
{
	if ( AmmoName == None )
		return;
	AmmoType = Ammunition(Other.FindInventoryType(AmmoName));
	if( AmmoType != None )
	{
		AmmoType.AddAmmo( ReloadCount );
	}
	else
	{
		AmmoType = Spawn(AmmoName);	// Create ammo type required		
		Other.AddInventory(AmmoType);		// and add to player's inventory
		AmmoType.AmmoAmount = PickUpAmmoCount; 
	}
}	

//////////////////////////////////
// Animation & related functions
//
simulated function TweenDown()
{
	local name Anim;
	local float frame,rate;

	if ( IsAnimating() && AnimIsInGroup(0,'Select') )
	{
		GetAnimParams(0,Anim,frame,rate);
		TweenAnim( Anim, frame * 0.4 );
	}
	else
	{
		// This from Weapon
		// Joe Pearce added AnimIsInGroup check. Not quite the same as the PlayReloading code wrt sound.
		if (AnimIsInGroup(0, 'Down'))
		{
			PlayAnim('Down', 1.0, 0.05);
		}
		else
			AnimEnd(0);

		// This is from WarfareWeapon.
		//PlayAnim('Holster', 1.0, 0.05);
		//PlayOwnedSound(HolsterSound);
	}
}

simulated function PlayReloading()
{
	local B9_BasicPlayerPawn P;

	P = B9_BasicPlayerPawn( Owner );
	if( P != None )
	{
		P.PlayReloadingAnim();
	}
		
	PlayOwnedSound( GetReloadSound(), SLOT_None, 1.0 );
}


simulated function AttachToPawn(Pawn P)
{
	local name BoneName;

	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}
	BoneName = P.GetWeaponBoneFor(self);
	if ( BoneName == '' )
	{
		ThirdPersonActor.SetLocation(P.Location);
		ThirdPersonActor.SetBase(P);
	}
	else
	{
		P.AttachToBone(ThirdPersonActor,BoneName);
	}

	ThirdPersonActor.SetRelativeLocation(ThirdPersonActor.Default.RelativeLocation);
	ThirdPersonActor.SetRelativeRotation(ThirdPersonActor.Default.RelativeRotation);
}

//////////////////////////////////
// Firing functions
//

function SniperTrace( out actor HitActor, out float Range )
{
	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;

	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	StartTrace = GetFireStart(X,Y,Z); 
	AdjustedAim = Instigator.AdjustAim(AmmoType, StartTrace, 0);	
	EndTrace = StartTrace;
	X = vector(AdjustedAim);
	EndTrace += (10000 * X); 
	HitActor = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);
	Range = vSize( HitLocation - StartTrace );
}

simulated function FakeTrace()
{
	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
	local actor Other;

	Owner.MakeNoise(1.0);
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	StartTrace = GetFireStart(X,Y,Z); 
	EndTrace = StartTrace + TraceDist * X; 
	Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);
	if( Other == None )
	{
		HitLocation = EndTrace;
	}
	if( ThirdPersonActor != None )
	{
		B9_WeaponAttachment(ThirdPersonActor).HitLoc=HitLocation;
//		B9_WeaponAttachment(ThirdPersonActor).ThirdPersonEffects();
	}
}

function TraceFire( float Accuracy, float YOffset, float ZOffset )
{
	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
	local actor Other;

	Owner.MakeNoise(1.0);
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	StartTrace = GetFireStart(X,Y,Z); 
	AdjustedAim = Instigator.AdjustAim(AmmoType, StartTrace, 2*AimError);	
	EndTrace = StartTrace + (YOffset + Accuracy * (FRand() - 0.5 ) ) * Y * 1000
		+ (ZOffset + Accuracy * (FRand() - 0.5 )) * Z * 1000;
	X = vector(AdjustedAim);
	EndTrace += (TraceDist * X);
	Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);

	if( Other == None )
	{
		HitLocation = EndTrace;
	}
	if( ThirdPersonActor != None )
	{
		B9_WeaponAttachment(ThirdPersonActor).HitLoc=HitLocation;
	}

	AmmoType.ProcessTraceHit(self, Other, HitLocation, HitNormal, X,Y,Z);
}

function TraceShotgunFire( float Accuracy, float YOffset, float ZOffset )
{
	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
	local actor Other;
	local B9AmmunitionBase	b9ammo;
	local byte	numTraces;

	b9ammo = B9AmmunitionBase( AmmoType );
	if( b9ammo == None )
	{
		return;
	}

	Owner.MakeNoise(1.0);
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	StartTrace = GetFireStart(X,Y,Z); 

	for( numTraces = 0; numTraces < fShotgunPellets; numTraces++ )
	{
		Accuracy = fIntrinsicInaccuracy + ( fInaccuracyIncrement * numTraces );

		AdjustedAim = Instigator.AdjustAim(AmmoType, StartTrace, 2*AimError);	
		EndTrace = StartTrace + (YOffset + Accuracy * (FRand() - 0.5 ) ) * Y * 1000
			+ (ZOffset + Accuracy * (FRand() - 0.5 )) * Z * 1000;
		X = vector(AdjustedAim);
		EndTrace += (TraceDist * X);
		Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);

		if( Other == None )
		{
			HitLocation = EndTrace;
		}
		if( ThirdPersonActor != None )
		{
			B9_WeaponAttachment(ThirdPersonActor).HitLoc=HitLocation;
		}

		if( numTraces < ( fShotgunPellets-1 ) )
		{
			b9ammo.ProcessShotgunTraceHit(self, Other, HitLocation, HitNormal, X,Y,Z, false );
		}
		else
		{
            b9ammo.ProcessShotgunTraceHit(self, Other, HitLocation, HitNormal, X,Y,Z, true );
		}
	}
}


function ProjectileFire()
{
	local Vector Start, X,Y,Z;
	local Rotator rot;

	Owner.MakeNoise( GetNoiseLevel() );
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	B9_WeaponAttachment( ThirdPersonActor ).GetEffectStart(Start, rot);
	AdjustedAim = Instigator.AdjustAim(AmmoType, Start, AimError);	
	AmmoType.SpawnProjectile(Start,AdjustedAim);	
}


//////////////////////////////////
// Firing functions for starting & stopping fx
//

simulated function IncrementFlashCount()
{
	FlashCount++;
	if ( WeaponAttachment(ThirdPersonActor) != None )
	{
		WeaponAttachment(ThirdPersonActor).FlashCount = FlashCount;
		WeaponAttachment(ThirdPersonActor).ThirdPersonEffects();
	}
}

simulated function ClientStoppedPressingFire()
{
	AdjustAccuracy( true );
	B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
}


simulated function PlayFiring()
{
	local PlayerController	PC;

	PlayOwnedSound( GetFireSound(), SLOT_None, fFireSoundVolumeLevel,,fFireSoundRadius );
	IncrementFlashCount();

	B9_WeaponAttachment(ThirdPersonActor).bAutoFire = true;

	PC = PlayerController( Pawn( Owner ).Controller );
	if( PC != None )
	{
		PC.ClientPlayForceFeedback( fForceFeedbackEffectName );
	}
}

/////////////////////////////////////////////////////
// Firing logic
//

function bool BotFire(bool bFinished, optional name FiringMode)
{
	if ( !bFinished && !IsIdle() )
		return false;

	Instigator.Controller.bFire = 1;
	Instigator.Controller.bAltFire = 0;
	if ( !RepeatFire() )
	{
		Global.ServerFire();
	}
	else if ( StopFiringTime < Level.TimeSeconds + 0.3 )
	{
		StopFiringTime = Level.TimeSeconds + 0.6;
		Global.ServerRapidFire();
	}
	// in some situations, weapon might want to call CauseAltFire() instead, and set bAltFire=1
	return true;
}

// SCOTT@@@!! Take me out!
function bool IsIdle()
{
	return true;
}

simulated function Fire( float Value )
{
	if( !CanFire() )
	{
		return;
	}

	SetActionExclusivity( true );
	ServerFire();

	if( Role < ROLE_Authority )
	{
		if( !NeedsToReload() && ( ReloadCount > 0 || !fUsesAmmo ) )
		{
			ExpendAmmoFromClip();
			LocalFire();
			GotoState('ClientFiring');
		}
		else
		{
			B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
			ClientStoppedPressingFire();
			SetActionExclusivity( false );

			if( NeedsToReload() && AmmoType.HasAmmo() )
			{
				GotoState('Reloading');
				return;
			}
			else if( NeedsToReload() && !AmmoType.HasAmmo() && Instigator != None && Instigator.IsLocallyControlled() )
			{
				PlaySound( GetEmptySound(), SLOT_None, 1.0, false );
				GotoState('Idle');
			}
		}
	}
}

function ServerFire()
{
	if ( AmmoType == None )
	{
		GiveAmmo(Pawn(Owner));
	}
    if ( !NeedsToReload() && ( ReloadCount > 0 || !fUsesAmmo ) )
	{
		ExpendAmmoFromClip();
		GotoState('NormalFire');

		if ( AmmoType.bInstantHit )
		{
			if( fShotgunWeapon )
			{
				TraceShotgunFire( 0.0, 0.0, 0.0 );
			}
			else
			{
				AdjustAccuracy();
				TraceFire( TraceAccuracy, 0.0, 0.0 );
			}
		}
		else
		{
			ProjectileFire();
		}

		ApplyKick();
		LocalFire();
	}
	else
	{
		if( Instigator != None && Instigator.IsLocallyControlled() )
		{
			B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
			ClientStoppedPressingFire();
			SetActionExclusivity( false );
		}

		if( NeedsToReload() && AmmoType.HasAmmo() )
		{
			GotoState('Reloading');
			return;
		}
		else if( NeedsToReload() && !AmmoType.HasAmmo() && Instigator != None && Instigator.IsLocallyControlled() )
		{
			PlaySound( GetEmptySound(), SLOT_None, 1.0, false );
			GotoState( 'Idle' );
		}
	}
}

simulated function LocalFire()
{
	local PlayerController P;

	bPointing = true;

	if (fMeleeWeapon)
	{
		PlayFiring();
	}
	else
	{
		if ( (Instigator != None) && Instigator.IsLocallyControlled() )
		{
			P = PlayerController(Instigator.Controller);
			if (P!=None)
			{
				P.ShakeView(ShakeTime, ShakeMag, ShakeVert, 120000, ShakeSpeed, 1);
			}
		}
		if ( Affector != None )
		{
			Affector.FireEffect();
		}

		PlayFiring();
	}
}		


function Finish()
{
	if ( NeedsToReload() )
	{
		if( AmmoType.HasAmmo() )
		{
			if( Instigator.IsLocallyControlled() )
			{
				B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
				ClientStoppedPressingFire();
			}
			GotoState('Reloading');
		}
		else
		{
			SetActionExclusivity( false );
			GotoState( 'Idle' );
		}

		return;
	}
	
	if( Instigator.IsLocallyControlled() && !Instigator.PressingFire() )
	{
		B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
		ClientStoppedPressingFire();		
		SetActionExclusivity( false );
	}
	
	GotoState( 'Idle' );

	Super.Finish();
}



simulated function ClientFinish()
{
	SetActionExclusivity( false );

	if ( (Instigator == None) || (Instigator.Controller == None) )
	{
		B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
		ClientStoppedPressingFire();
		GotoState('');
		return;
	}

	if ( NeedsToReload() )
	{
		B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
		ClientStoppedPressingFire();
		SetActionExclusivity( false );

		if( AmmoType.HasAmmo() )
		{
			GotoState('Reloading');
			return;
		}
		else
		{
			GotoState('Idle');
			return;
		}
	}
	
	if ( Instigator.PressingFire() )
	{
		Global.Fire(0);
	}
	else
	{
		B9_WeaponAttachment(ThirdPersonActor).bAutoFire = false;
		ClientStoppedPressingFire();
		GotoState('');
	}
}


//////////////////////////////////
// States
//

simulated state Idle
{
	simulated function ForceReload()
	{
		if( NeedsToReload() )
		{
            ServerForceReload();
		}
	}

Begin:
	SetActionExclusivity( false );
}

state NormalFire
{
	ignores AnimEnd;

	function Fire(float F) {}
	function AltFire(float F) {} 

Begin:
	Sleep( GetROF() );
	Finish();
}

simulated state ClientFiring
{
	function Fire( float Value ) {}
	function AltFire( float Value ) {}
	simulated function AnimEnd(int Channel)	{}
	function CheckAnimating() {}

	simulated function EndState() {}
	simulated function BeginState() {}

Begin:
	Sleep( GetROF() );
	ClientFinish();
}

state Active
{
	simulated function BeginState()
	{
		if( NeedsToReload() && AmmoType.HasAmmo() )
		{
			GotoState( 'Reloading' );
			ClientForceReload();
		}

		Instigator		= Pawn( Owner );
		bForceFire		= false;
		bForceAltFire	= false;
		bWeaponUp		= false;
		bChangeWeapon	= false;

		AnimEnd(0); // causes Engine.Weapon::Active to end normally
	}
}

simulated state Reloading
{
	function ServerForceReload() {}
	function ClientForceReload() {}
	function Fire( float Value ) {}
	function AltFire( float Value ) {}
	function ServerFire() {}
	function ServerAltFire() {}
	simulated function bool PutDown() { return false; }
	simulated function AnimEnd(int Channel) {}
	function CheckAnimating() {}
	
	simulated function ClientFinish()
	{
		GotoState( 'Idle' );
	}

	simulated function BeginState()
	{
		bForceReload = false;
	}

	simulated function LoadGun()
	{
		local int numAvailable;
		
		numAvailable = AmmoType.AmmoAmount;

		if( numAvailable >= Default.ReloadCount )
		{
			ReloadCount = Default.ReloadCount;
		}
		else
		{
			ReloadCount = AmmoType.AmmoAmount;
		}
	}

	simulated function Tick( float DeltaTime )
	{
		if( !Pawn( Owner ).IsAnimating( 15 ) )
		{
			if( Role == ROLE_Authority )
			{
				Finish();
			}
			else
			{
				ClientFinish();
			}
		}
	}

Begin:
	PlayReloading();
	LoadGun();
}


//////////////////////////////////
// Initialization
//

defaultproperties
{
	fOptimalRange=500
	fROF=60
	fNoiseLevel=1
	fFireSoundVolumeLevel=1
	fFireSoundRadius=100
	fEmptySound=Sound'B9SoundFX.Weapon.wep_MT'
	fReloadSound=Sound'B9SoundFX.Weapon.wep_reload'
	fScopeMagnify=1
	fScopeMaxMagnify=10
	fSniperReticule=Shader'B9HUD_textures.Targeting_reticles.sniper_reticle'
	fSniperBackdrop=Shader'B9HUD_textures.Targeting_reticles.Peripheral_blackout'
	fUsesAmmo=true
	fUsesClips=true
	FireOffset=(X=20,Y=4,Z=-5)
	CrossHair=Texture'Icons.CHair1'
	TraceDist=1000
	MaxRange=1000
	MessageNoAmmo="Reload"
}